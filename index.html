<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HYPERION / The Demand That Predicts Itself</title>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Libraries -->
    <script src="https://unpkg.com/@studio-freight/lenis@1.0.29/dist/lenis.min.js"></script>
    <script src="https://unpkg.com/scrollama@3.2.0/build/scrollama.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            overflow-x: hidden;
        }

        :root {
            --white: #FFFFFF;
            --almost-white: #FAFBFC;
            --soft-gray: #E8ECEF;
            --text-primary: #1A1F2E;
            --text-secondary: #5A6472;
            --accent-cyan: #CFFAFB;
            --accent-lilac: #A5B4FF;
            --accent-blue: #C6E1FF;
            --gradient-mist: linear-gradient(135deg, rgba(207, 250, 251, 0.3), rgba(165, 180, 255, 0.2));
        }

        body {
            font-family: 'Space Grotesk', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--white);
            color: var(--text-primary);
            overflow-x: hidden;
            line-height: 1.7;
            -webkit-font-smoothing: antialiased;
            width: 100%;
            position: relative;
        }

        .section {
            min-height: 100vh;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8rem 5vw;
            overflow: hidden;
        }

        .section--tall {
            min-height: 150vh;
        }

        /* Parallax Background Container */
        .parallax-bg {
            position: absolute;
            top: -20%;
            left: -10%;
            width: 120%;
            height: 175vh;
            z-index: -1;
            will-change: transform;
            transition: transform 0.1s linear;
        }

        .parallax-bg img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0.15;
            filter: contrast(1.1) brightness(1.1);
        }

        .parallax-bg--gradient {
            background: linear-gradient(
                135deg,
                rgba(207, 250, 251, 0.3) 0%,
                rgba(165, 180, 255, 0.2) 25%,
                rgba(198, 225, 255, 0.3) 50%,
                rgba(207, 250, 251, 0.2) 75%,
                rgba(165, 180, 255, 0.3) 100%
            );
            background-size: 200% 200%;
            animation: gradientShift 20s ease infinite;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .section__content {
            max-width: 1000px;
            width: 100%;
            opacity: 0;
            transform: translateY(60px) scale(0.98);
            transition: all 2s cubic-bezier(0.19, 1, 0.22, 1);
            position: relative;
            z-index: 1;
        }

        .section__content.active {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        .section--pinned {
            height: 300vh;
        }

        .section--pinned .sticky-container {
            position: sticky;
            top: 0;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
        }

        h1 {
            font-size: clamp(3rem, 8vw, 7rem);
            font-weight: 300;
            line-height: 1.1;
            margin-bottom: 2rem;
            letter-spacing: -0.02em;
            animation: fadeInUp 1.5s cubic-bezier(0.19, 1, 0.22, 1) 0.2s both;
        }

        h2 {
            font-size: clamp(2rem, 5vw, 4.5rem);
            font-weight: 400;
            line-height: 1.2;
            margin-bottom: 2rem;
            letter-spacing: -0.01em;
            animation: fadeInUp 1.5s cubic-bezier(0.19, 1, 0.22, 1) 0.4s both;
        }

        h3 {
            font-size: clamp(1.5rem, 3vw, 2.5rem);
            font-weight: 500;
            margin-bottom: 1.5rem;
        }

        p {
            font-size: clamp(1.1rem, 2vw, 1.4rem);
            line-height: 1.8;
            color: var(--text-secondary);
            max-width: 700px;
            margin-bottom: 1.5rem;
            animation: fadeInUp 1.5s cubic-bezier(0.19, 1, 0.22, 1) 0.6s both;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(40px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .gradient-bg {
            position: absolute;
            inset: 0;
            background: var(--gradient-mist);
            opacity: 0.6;
            transition: transform 0.5s ease-out;
        }

        .metric {
            font-size: clamp(3rem, 6vw, 5rem);
            font-weight: 600;
            color: var(--text-primary);
            margin: 1rem 0;
            display: block;
            background: linear-gradient(135deg, var(--text-primary), var(--accent-lilac));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .metric-label {
            font-size: 1.1rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-weight: 500;
        }

        .grid-2 {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 3rem;
            margin: 3rem 0;
            width: 100%;
        }

        #chart-container,
        #scatter-container,
        #network-container,
        #bar-container,
        #stream-container {
            width: 100%;
            max-width: 100%;
            height: 400px;
            margin: 3rem 0;
            overflow: hidden;
        }

        .icon-orbit {
            width: min(500px, 90vw);
            height: min(500px, 90vw);
            position: relative;
            margin: 4rem auto;
        }

        .orbit-item {
            position: absolute;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-cyan));
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-primary);
            box-shadow: 0 10px 30px rgba(165, 180, 255, 0.3);
            transition: all 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .orbit-item:hover {
            transform: scale(1.1);
            box-shadow: 0 15px 40px rgba(165, 180, 255, 0.5);
        }

        .data-stream {
            position: relative;
            width: 100%;
            height: 300px;
            overflow: hidden;
        }

        .stream-line {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--accent-lilac), transparent);
            animation: stream 3s ease-in-out infinite;
        }

        @keyframes stream {
            0% { 
                transform: translateX(-100%) scaleX(0.5);
                opacity: 0;
            }
            50% { 
                opacity: 1;
                transform: translateX(0) scaleX(1);
            }
            100% { 
                transform: translateX(200%) scaleX(0.5);
                opacity: 0;
            }
        }

        .tooltip {
            position: absolute;
            background: rgba(26, 31, 46, 0.95);
            color: white;
            padding: 0.8rem 1.2rem;
            border-radius: 8px;
            font-size: 0.9rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .world-map {
            width: 100%;
            height: 500px;
            position: relative;
            background: radial-gradient(ellipse at center, rgba(207, 250, 251, 0.3) 0%, transparent 70%);
            overflow: hidden;
            border-radius: 20px;
        }

        .pulse-line {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--accent-lilac), transparent);
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
            opacity: 0.7;
        }

        @keyframes pulse {
            0%, 100% { 
                opacity: 0.3;
                transform: scaleX(0.95) translateZ(0);
            }
            50% { 
                opacity: 0.8;
                transform: scaleX(1.05) translateZ(0);
            }
        }

        .logo {
            font-size: 2.5rem;
            font-weight: 700;
            letter-spacing: 0.15em;
            text-align: center;
            opacity: 0;
            transform: scale(0.9);
            transition: all 3s cubic-bezier(0.19, 1, 0.22, 1);
        }

        .logo.visible {
            opacity: 1;
            transform: scale(1);
        }

        .dashboard-panel {
            flex: 1;
            height: 200px;
            background: linear-gradient(135deg, var(--soft-gray), rgba(165, 180, 255, 0.1));
            border-radius: 12px;
            opacity: 0;
            transform: translateY(30px);
            transition: all 1.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.05);
        }

        .dashboard-panel.visible {
            opacity: 1;
            transform: translateY(0);
        }

        /* Improved responsive design */
        @media (max-width: 768px) {
            .section {
                min-height: 100vh;
                padding: 4rem 5vw;
            }
            
            .icon-orbit {
                width: 300px;
                height: 300px;
            }
            
            .orbit-item {
                width: 60px;
                height: 60px;
                font-size: 0.7rem;
            }

            .grid-2 {
                grid-template-columns: 1fr;
                gap: 2rem;
            }
        }

        /* Prevent horizontal scroll */
        .section > * {
            max-width: 100%;
        }

        svg {
            max-width: 100%;
            height: auto;
        }
    </style>
</head>
<body>

    <!-- Section 1: Arrival -->
    <section class="section section--tall" data-section="1">
        <div class="parallax-bg parallax-bg--gradient" data-speed="0.5"></div>
        <div class="section__content">
            <h1>HYPERION</h1>
            <h2>The Demand That Predicts Itself</h2>
            <p>Energy demand breathes in rhythm.<br>
            HYPERION listens—and forecasts the next beat.</p>
        </div>
    </section>

    <!-- Section 2: Problem Context -->
    <section class="section" data-section="2">
        <div class="parallax-bg" data-speed="0.3">
            <img src="https://images.unsplash.com/photo-1451187580459-43490279c0fa?w=1920&q=20" alt="Abstract waves">
        </div>
        <div class="section__content">
            <h2>Predicting LPG demand is a puzzle of weather, economy, and habit.</h2>
            <p>Experience once guided it; now intelligence sees what intuition can't.</p>
            <div class="world-map" id="world-map">
                <div class="pulse-line" style="top: 30%; left: 20%; width: 40%; transform: rotate(-15deg);"></div>
                <div class="pulse-line" style="top: 50%; left: 40%; width: 35%; transform: rotate(25deg); animation-delay: 0.5s;"></div>
                <div class="pulse-line" style="top: 70%; left: 15%; width: 50%; transform: rotate(-8deg); animation-delay: 1s;"></div>
            </div>
        </div>
    </section>

    <!-- Section 3: Data Flow (Pinned) -->
    <section class="section section--pinned" data-section="3">
        <div class="parallax-bg" data-speed="0.4">
            <img src="https://images.unsplash.com/photo-1518432031352-d6fc5c10da5a?w=1920&q=20" alt="Data visualization">
        </div>
        <div class="sticky-container">
            <div class="section__content">
                <h2>Each month, thousands of records arrive—</h2>
                <p>consumption, temperature, seasonality.<br>
                HYPERION reads the melody hidden inside numbers.</p>
                <div id="stream-container"></div>
            </div>
        </div>
    </section>

    <!-- Section 4A: XGBoost -->
    <section class="section section--tall" data-section="4a">
        <div class="parallax-bg" data-speed="0.6">
            <img src="https://images.unsplash.com/photo-1635070041078-e363dbe005cb?w=1920&q=20" alt="Neural network">
        </div>
        <div class="section__content">
            <h2>XGBoost: The Model as Instrument</h2>
            <p>
                <span class="metric" id="trees-counter">0</span>
                <span class="metric-label">trees trained on 240 months.</span>
            </p>
            <p>Each corrects the last until MAPE = 
                <span class="metric" style="display: inline; font-size: 2.5rem;" id="mape-counter">10.0</span>%,
                <br>60% better than old linear models.<br>
                Precision at industrial scale.
            </p>
            <div id="tree-viz" style="width: 100%; height: 300px; margin: 3rem 0;"></div>
        </div>
    </section>

    <!-- Section 4B: Toolchain -->
    <section class="section" data-section="4b">
        <div class="parallax-bg parallax-bg--gradient" data-speed="0.5"></div>
        <div class="section__content">
            <h2>Toolchain</h2>
            <div class="icon-orbit" id="orbit-container">
                <div class="orbit-item" style="top: 50%; left: 50%; transform: translate(-50%, -50%);">Core</div>
            </div>
            <div class="grid-2">
                <div>
                    <p><strong>Pandas</strong> cleans <span id="rows-counter">0</span> rows.</p>
                    <p><strong>NumPy</strong> handles millions of ops.</p>
                </div>
                <div>
                    <p><strong>Scikit-learn</strong> validates.</p>
                    <p><strong>D3.js</strong> turns math into motion.</p>
                </div>
            </div>
        </div>
    </section>

    <!-- Section 4C: Resilience -->
    <section class="section" data-section="4c">
        <div class="parallax-bg" data-speed="0.3">
            <img src="https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=1920&q=20" alt="Data charts">
        </div>
        <div class="section__content">
            <h2>Resilience</h2>
            <p>Cross-validation across four folds; no overfit.<br>
            Feature influence: Temp 41%, Season 33%, Growth 18%, Noise 8%.<br>
            Prediction with reason.</p>
            <div id="bar-container"></div>
        </div>
    </section>

    <!-- Section 4D: Proof of Power -->
    <section class="section" data-section="4d">
        <div class="parallax-bg parallax-bg--gradient" data-speed="0.4"></div>
        <div class="section__content">
            <h2>Proof of Power</h2>
            <div class="grid-2">
                <div>
                    <span class="metric" id="waste-counter">0</span>
                    <span class="metric-label">less inventory waste</span>
                </div>
                <div>
                    <span class="metric" id="shipment-counter">0</span>
                    <span class="metric-label">faster shipments</span>
                </div>
                <div>
                    <span class="metric" id="savings-counter">$0M</span>
                    <span class="metric-label">saved</span>
                </div>
                <div>
                    <span class="metric" id="runtime-counter">0</span>
                    <span class="metric-label">forecast runtime</span>
                </div>
            </div>
        </div>
    </section>

    <!-- Section 5: Forecast in Motion (Pinned) -->
    <section class="section section--pinned" data-section="5">
        <div class="parallax-bg" data-speed="0.5">
            <img src="https://images.unsplash.com/photo-1504868584819-f8e8b4b6d7e3?w=1920&q=20" alt="Graph visualization">
        </div>
        <div class="sticky-container">
            <div class="section__content">
                <h2>Forecast in Motion</h2>
                <p>Scroll forward—the future unfolds.<br>
                The line extends, confidence band breathing around it.</p>
                <div id="chart-container"></div>
            </div>
        </div>
    </section>

    <!-- Section 6: Validation -->
    <section class="section" data-section="6">
        <div class="parallax-bg" data-speed="0.3">
            <img src="https://images.unsplash.com/photo-1527474305487-b87b222841cc?w=1920&q=20" alt="Validation">
        </div>
        <div class="section__content">
            <h2>Validation</h2>
            <p>Accuracy verified on unseen months.<br>
            Predicted vs actual—near-perfect correlation.</p>
            <div id="scatter-container"></div>
        </div>
    </section>

    <!-- Section 7: Business Translation -->
    <section class="section" data-section="7">
        <div class="parallax-bg parallax-bg--gradient" data-speed="0.4"></div>
        <div class="section__content">
            <h2>Business Translation</h2>
            <p>Inventory meets demand.<br>
            Trucks leave on time.<br>
            Budgets anticipate seasons.</p>
            <div style="width: 100%; height: 400px; background: linear-gradient(135deg, rgba(198, 225, 255, 0.3), rgba(207, 250, 251, 0.3)); border-radius: 20px; margin: 3rem 0; backdrop-filter: blur(10px);"></div>
        </div>
    </section>

    <!-- Section 8: Strategic Leverage (Pinned) -->
    <section class="section section--pinned" data-section="8">
        <div class="parallax-bg" data-speed="0.5">
            <img src="https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=1920&q=20" alt="Dashboard">
        </div>
        <div class="sticky-container">
            <div class="section__content">
                <h2>Strategic Leverage</h2>
                <p>Uncertainty shrinks.<br>
                Reaction becomes prediction.<br>
                Intuition becomes insight.</p>
                <div style="width: 100%; height: 300px; display: flex; gap: 2rem; align-items: center; justify-content: center; margin: 3rem 0;">
                    <div class="dashboard-panel"></div>
                    <div class="dashboard-panel"></div>
                    <div class="dashboard-panel"></div>
                </div>
            </div>
        </div>
    </section>

    <!-- Section 9: Expansion -->
    <section class="section" data-section="9">
        <div class="parallax-bg parallax-bg--gradient" data-speed="0.3"></div>
        <div class="section__content">
            <h2>Expansion</h2>
            <p>Freight. Finance. Healthcare. Agriculture.<br>
            Wherever data moves through time, HYPERION learns.</p>
            <div class="grid-2" style="margin-top: 4rem;">
                <div style="height: 200px; background: linear-gradient(135deg, rgba(207, 250, 251, 0.4), rgba(165, 180, 255, 0.2)); border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; font-weight: 500; transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); cursor: pointer;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">Freight</div>
                <div style="height: 200px; background: linear-gradient(135deg, rgba(165, 180, 255, 0.4), rgba(198, 225, 255, 0.2)); border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; font-weight: 500; transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); cursor: pointer;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">Finance</div>
                <div style="height: 200px; background: linear-gradient(135deg, rgba(198, 225, 255, 0.4), rgba(207, 250, 251, 0.2)); border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; font-weight: 500; transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); cursor: pointer;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">Healthcare</div>
                <div style="height: 200px; background: linear-gradient(135deg, rgba(207, 250, 251, 0.4), rgba(165, 180, 255, 0.3)); border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; font-weight: 500; transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); cursor: pointer;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">Agriculture</div>
            </div>
        </div>
    </section>

    <!-- Section 10: Decision OS -->
    <section class="section section--tall" data-section="10">
        <div class="parallax-bg" data-speed="0.4">
            <img src="https://images.unsplash.com/photo-1558618666-fcd25c85cd64?w=1920&q=20" alt="Network">
        </div>
        <div class="section__content">
            <h2>Decision OS</h2>
            <p>Modules communicating in a living network—<br>
            models that learn from each other.</p>
            <div id="network-container"></div>
        </div>
    </section>

    <!-- Section 11: Finale -->
    <section class="section section--tall" data-section="11">
        <div class="parallax-bg parallax-bg--gradient" data-speed="0.2"></div>
        <div class="section__content">
            <h2>Forecasting becomes geometry:</h2>
            <p style="font-size: 1.6rem; max-width: 800px;">
                patterns → prediction → strategy.
            </p>
            <p style="margin-top: 3rem;">
                The question isn't <em>can we know the future</em>—<br>
                but how precisely we'll shape it.
            </p>
            <div class="logo" id="final-logo" style="margin-top: 6rem;">HYPERION</div>
        </div>
    </section>

    <script>
        // Initialize Lenis smooth scrolling with better settings
        const lenis = new Lenis({
            duration: 1.8,
            easing: (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),
            direction: 'vertical',
            smooth: true,
            smoothTouch: false,
            touchMultiplier: 2,
            infinite: false,
        });

        function raf(time) {
            lenis.raf(time);
            requestAnimationFrame(raf);
        }
        requestAnimationFrame(raf);

        // Parallax effect for background images
        window.addEventListener('scroll', () => {
            const scrolled = window.pageYOffset;
            const parallaxElements = document.querySelectorAll('.parallax-bg');
            
            parallaxElements.forEach(element => {
                const speed = element.dataset.speed || 0.5;
                const yPos = -(scrolled * speed);
                const scale = 1 + (scrolled * 0.0001);
                element.style.transform = `translateY(${yPos}px) scale(${Math.min(scale, 1.15)})`;
            });
        });

        // Scrollama setup
        const scroller = scrollama();

        scroller
            .setup({
                step: '.section',
                offset: 0.5,
                debug: false,
            })
            .onStepEnter(response => {
                const section = response.element.dataset.section;
                const content = response.element.querySelector('.section__content');
                if (content) {
                    content.classList.add('active');
                }
                
                // Trigger specific animations per section
                switch(section) {
                    case '3':
                        createDataStream();
                        break;
                    case '4a':
                        animateCounters();
                        createTreeViz();
                        break;
                    case '4b':
                        animateOrbit();
                        animateRowsCounter();
                        break;
                    case '4c':
                        createBarChart();
                        break;
                    case '4d':
                        animateMetrics();
                        break;
                    case '5':
                        createForecastChart();
                        break;
                    case '6':
                        createScatterPlot();
                        break;
                    case '8':
                        showDashboards();
                        break;
                    case '10':
                        createNetworkGraph();
                        break;
                    case '11':
                        document.getElementById('final-logo').classList.add('visible');
                        break;
                }
            });

        // Enhanced Data stream animation
        let streamCreated = false;
        function createDataStream() {
            if (streamCreated) return;
            streamCreated = true;

            const container = d3.select('#stream-container');
            container.selectAll('*').remove();
            
            const rect = container.node().getBoundingClientRect();
            const width = rect.width;
            const height = 400;

            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height)
                .attr('viewBox', `0 0 ${width} ${height}`)
                .attr('preserveAspectRatio', 'xMidYMid meet');

            // Create flowing wave paths
            const waveData = d3.range(3).map(i => ({
                amplitude: 30 + i * 10,
                frequency: 0.01 + i * 0.002,
                speed: 0.5 + i * 0.2,
                yOffset: height / 2 + (i - 1) * 50
            }));

            const paths = svg.selectAll('path.wave')
                .data(waveData)
                .enter()
                .append('path')
                .attr('class', 'wave')
                .attr('fill', 'none')
                .attr('stroke', (d, i) => ['#A5B4FF', '#C6E1FF', '#CFFAFB'][i])
                .attr('stroke-width', 2)
                .attr('opacity', 0.6);

            let offset = 0;
            function animateWaves() {
                offset += 1;
                
                paths.attr('d', d => {
                    const points = d3.range(0, width, 5).map(x => {
                        const y = d.yOffset + Math.sin((x + offset * d.speed) * d.frequency) * d.amplitude;
                        return [x, y];
                    });
                    return d3.line().curve(d3.curveBasis)(points);
                });
                
                requestAnimationFrame(animateWaves);
            }
            animateWaves();

            // Add flowing particles
            const particles = d3.range(30).map(() => ({
                x: Math.random() * width,
                y: Math.random() * height,
                vx: 1 + Math.random() * 2,
                r: Math.random() * 3 + 1,
                opacity: Math.random() * 0.5 + 0.3
            }));

            const dots = svg.selectAll('circle.particle')
                .data(particles)
                .enter()
                .append('circle')
                .attr('class', 'particle')
                .attr('r', d => d.r)
                .attr('fill', '#A5B4FF')
                .attr('opacity', d => d.opacity);

            function updateParticles() {
                particles.forEach(p => {
                    p.x += p.vx;
                    if (p.x > width + 10) {
                        p.x = -10;
                        p.y = Math.random() * height;
                    }
                });

                dots
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);
            }

            d3.interval(updateParticles, 30);
        }

        // Enhanced counter animations with easing
        function animateCounters() {
            animateCounter('trees-counter', 0, 1200, 3000, 0);
            animateCounter('mape-counter', 10, 3.8, 3000, 1);
        }

        function animateCounter(id, start, end, duration, decimals, suffix = '', prefix = '') {
            const element = document.getElementById(id);
            if (!element || element.dataset.animated === 'true') return;
            element.dataset.animated = 'true';
            
            const startTime = performance.now();

            function update(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Enhanced easing function
                const eased = progress < 0.5
                    ? 4 * progress * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 3) / 2;
                
                const value = start + (end - start) * eased;
                
                element.textContent = prefix + value.toFixed(decimals) + suffix;

                if (progress < 1) {
                    requestAnimationFrame(update);
                }
            }

            requestAnimationFrame(update);
        }

        // Enhanced tree visualization
        let treeVizCreated = false;
        function createTreeViz() {
            if (treeVizCreated) return;
            treeVizCreated = true;

            const container = d3.select('#tree-viz');
            container.selectAll('*').remove();
            
            const rect = container.node().getBoundingClientRect();
            const width = rect.width;
            const height = 300;

            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height)
                .attr('viewBox', `0 0 ${width} ${height}`)
                .attr('preserveAspectRatio', 'xMidYMid meet');

            // Create tree structure with branches
            const trees = d3.range(12).map((d, i) => ({
                x: (i % 6) * (width / 6) + width / 12,
                y: Math.floor(i / 6) * 140 + 80,
                branches: d3.range(3).map(j => ({
                    angle: -60 + j * 60,
                    length: 20 + Math.random() * 10
                }))
            }));

            const treeGroups = svg.selectAll('g.tree')
                .data(trees)
                .enter()
                .append('g')
                .attr('class', 'tree')
                .attr('transform', d => `translate(${d.x}, ${d.y})`);

            // Trunk
            treeGroups.append('line')
                .attr('x1', 0)
                .attr('y1', 40)
                .attr('x2', 0)
                .attr('y2', 0)
                .attr('stroke', '#A5B4FF')
                .attr('stroke-width', 3)
                .attr('opacity', 0)
                .transition()
                .delay((d, i) => i * 100)
                .duration(800)
                .attr('opacity', 0.8);

            // Branches
            treeGroups.each(function(d) {
                const group = d3.select(this);
                d.branches.forEach((branch, i) => {
                    group.append('line')
                        .attr('x1', 0)
                        .attr('y1', 0)
                        .attr('x2', 0)
                        .attr('y2', 0)
                        .attr('stroke', '#C6E1FF')
                        .attr('stroke-width', 2)
                        .attr('opacity', 0)
                        .transition()
                        .delay((d, j) => trees.indexOf(d) * 100 + i * 50 + 400)
                        .duration(600)
                        .attr('x2', Math.cos(branch.angle * Math.PI / 180) * branch.length)
                        .attr('y2', Math.sin(branch.angle * Math.PI / 180) * branch.length)
                        .attr('opacity', 0.6);
                });
            });

            // Node
            treeGroups.append('circle')
                .attr('cx', 0)
                .attr('cy', 0)
                .attr('r', 0)
                .attr('fill', '#CFFAFB')
                .transition()
                .delay((d, i) => i * 100 + 200)
                .duration(800)
                .attr('r', 10);
        }

        // Enhanced orbit animation
        let orbitAnimated = false;
        function animateOrbit() {
            if (orbitAnimated) return;
            orbitAnimated = true;

            const tools = ['Pandas', 'NumPy', 'Scikit', 'D3.js'];
            const container = document.getElementById('orbit-container');
            const rect = container.getBoundingClientRect();
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            const radius = Math.min(rect.width, rect.height) * 0.35;

            tools.forEach((tool, i) => {
                const angle = (i / tools.length) * Math.PI * 2 - Math.PI / 2;
                const x = centerX + Math.cos(angle) * radius - 40;
                const y = centerY + Math.sin(angle) * radius - 40;

                const item = document.createElement('div');
                item.className = 'orbit-item';
                item.textContent = tool;
                item.style.left = centerX - 40 + 'px';
                item.style.top = centerY - 40 + 'px';
                item.style.opacity = '0';
                item.style.transform = 'scale(0)';
                container.appendChild(item);

                setTimeout(() => {
                    item.style.left = x + 'px';
                    item.style.top = y + 'px';
                    item.style.opacity = '1';
                    item.style.transform = 'scale(1)';
                }, i * 200);
            });

            // Gentle rotation
            let rotation = 0;
            setInterval(() => {
                rotation += 0.2;
                container.style.transform = `rotate(${rotation}deg)`;
                
                // Counter-rotate text
                const items = container.querySelectorAll('.orbit-item');
                items.forEach(item => {
                    if (item.textContent !== 'Core') {
                        item.style.transform = `rotate(${-rotation}deg)`;
                    }
                });
            }, 30);
        }

        function animateRowsCounter() {
            animateCounter('rows-counter', 0, 14000, 2500, 0);
        }

        // Enhanced bar chart
        let barChartCreated = false;
        function createBarChart() {
            if (barChartCreated) return;
            barChartCreated = true;

            const data = [
                { label: 'Temperature', value: 41, color: '#A5B4FF' },
                { label: 'Seasonality', value: 33, color: '#C6E1FF' },
                { label: 'Growth', value: 18, color: '#CFFAFB' },
                { label: 'Noise', value: 8, color: '#E8ECEF' }
            ];

            const container = d3.select('#bar-container');
            container.selectAll('*').remove();
            
            const rect = container.node().getBoundingClientRect();
            const width = rect.width;
            const height = 400;
            const margin = { top: 20, right: 20, bottom: 60, left: 60 };

            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height)
                .attr('viewBox', `0 0 ${width} ${height}`)
                .attr('preserveAspectRatio', 'xMidYMid meet');

            const x = d3.scaleBand()
                .domain(data.map(d => d.label))
                .range([margin.left, width - margin.right])
                .padding(0.3);

            const y = d3.scaleLinear()
                .domain([0, 50])
                .range([height - margin.bottom, margin.top]);

            // Add gradient definitions
            const defs = svg.append('defs');
            data.forEach((d, i) => {
                const gradient = defs.append('linearGradient')
                    .attr('id', `bar-gradient-${i}`)
                    .attr('x1', '0%')
                    .attr('y1', '100%')
                    .attr('x2', '0%')
                    .attr('y2', '0%');
                
                gradient.append('stop')
                    .attr('offset', '0%')
                    .attr('stop-color', d.color)
                    .attr('stop-opacity', 0.6);
                
                gradient.append('stop')
                    .attr('offset', '100%')
                    .attr('stop-color', d.color)
                    .attr('stop-opacity', 1);
            });

            // Bars with gradient
            svg.selectAll('rect')
                .data(data)
                .enter()
                .append('rect')
                .attr('x', d => x(d.label))
                .attr('y', height - margin.bottom)
                .attr('width', x.bandwidth())
                .attr('height', 0)
                .attr('fill', (d, i) => `url(#bar-gradient-${i})`)
                .attr('rx', 8)
                .transition()
                .duration(1500)
                .delay((d, i) => i * 200)
                .ease(d3.easeCubicOut)
                .attr('y', d => y(d.value))
                .attr('height', d => height - margin.bottom - y(d.value));

            // Labels
            svg.selectAll('text.label')
                .data(data)
                .enter()
                .append('text')
                .attr('class', 'label')
                .attr('x', d => x(d.label) + x.bandwidth() / 2)
                .attr('y', height - margin.bottom + 25)
                .attr('text-anchor', 'middle')
                .attr('font-size', '14px')
                .attr('fill', '#5A6472')
                .attr('opacity', 0)
                .text(d => d.label)
                .transition()
                .delay((d, i) => i * 200 + 500)
                .duration(500)
                .attr('opacity', 1);

            // Values
            svg.selectAll('text.value')
                .data(data)
                .enter()
                .append('text')
                .attr('class', 'value')
                .attr('x', d => x(d.label) + x.bandwidth() / 2)
                .attr('y', d => y(d.value) - 10)
                .attr('text-anchor', 'middle')
                .attr('font-size', '18px')
                .attr('font-weight', '600')
                .attr('fill', '#1A1F2E')
                .attr('opacity', 0)
                .text(d => d.value + '%')
                .transition()
                .duration(500)
                .delay((d, i) => i * 200 + 1500)
                .attr('opacity', 1);
        }

        // Metrics animation
        function animateMetrics() {
            animateCounter('waste-counter', 0, 12, 2500, 0, '%');
            setTimeout(() => {
                animateCounter('shipment-counter', 0, 18, 2500, 0, '%');
            }, 300);
            setTimeout(() => {
                animateCounter('savings-counter', 0, 4.7, 2500, 1, 'M', '$');
            }, 600);
            setTimeout(() => {
                animateCounter('runtime-counter', 0, 1.3, 2500, 1, 's');
            }, 900);
        }

        // Enhanced forecast chart
        let forecastCreated = false;
        function createForecastChart() {
            if (forecastCreated) return;
            forecastCreated = true;

            const container = d3.select('#chart-container');
            container.selectAll('*').remove();
            
            const rect = container.node().getBoundingClientRect();
            const width = rect.width;
            const height = 400;
            const margin = { top: 20, right: 20, bottom: 40, left: 50 };

            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height)
                .attr('viewBox', `0 0 ${width} ${height}`)
                .attr('preserveAspectRatio', 'xMidYMid meet');

            // Generate smoother data
            const historical = d3.range(24).map(i => ({
                month: i,
                value: 50 + Math.sin(i / 3) * 15 + Math.cos(i / 7) * 5 + (Math.random() - 0.5) * 3
            }));

            const forecast = d3.range(24, 36).map(i => ({
                month: i,
                value: 50 + Math.sin(i / 3) * 15 + Math.cos(i / 7) * 5,
                upper: 50 + Math.sin(i / 3) * 15 + Math.cos(i / 7) * 5 + 8,
                lower: 50 + Math.sin(i / 3) * 15 + Math.cos(i / 7) * 5 - 8
            }));

            const x = d3.scaleLinear()
                .domain([0, 36])
                .range([margin.left, width - margin.right]);

            const y = d3.scaleLinear()
                .domain([20, 80])
                .range([height - margin.bottom, margin.top]);

            // Add gradient for confidence band
            const defs = svg.append('defs');
            const gradient = defs.append('linearGradient')
                .attr('id', 'confidence-gradient')
                .attr('x1', '0%')
                .attr('y1', '0%')
                .attr('x2', '0%')
                .attr('y2', '100%');
            
            gradient.append('stop')
                .attr('offset', '0%')
                .attr('stop-color', '#C6E1FF')
                .attr('stop-opacity', 0.1);
            
            gradient.append('stop')
                .attr('offset', '50%')
                .attr('stop-color', '#C6E1FF')
                .attr('stop-opacity', 0.4);
            
            gradient.append('stop')
                .attr('offset', '100%')
                .attr('stop-color', '#C6E1FF')
                .attr('stop-opacity', 0.1);

            // Confidence band
            const area = d3.area()
                .x(d => x(d.month))
                .y0(d => y(d.lower))
                .y1(d => y(d.upper))
                .curve(d3.curveCatmullRom);

            svg.append('path')
                .datum(forecast)
                .attr('fill', 'url(#confidence-gradient)')
                .attr('opacity', 0)
                .attr('d', area)
                .transition()
                .delay(2500)
                .duration(1000)
                .attr('opacity', 1);

            // Historical line
            const line = d3.line()
                .x(d => x(d.month))
                .y(d => y(d.value))
                .curve(d3.curveCatmullRom);

            const historicalPath = svg.append('path')
                .datum(historical)
                .attr('fill', 'none')
                .attr('stroke', '#1A1F2E')
                .attr('stroke-width', 3)
                .attr('d', line);

            const historicalLength = historicalPath.node().getTotalLength();

            historicalPath
                .attr('stroke-dasharray', historicalLength)
                .attr('stroke-dashoffset', historicalLength)
                .transition()
                .duration(2500)
                .ease(d3.easeQuadInOut)
                .attr('stroke-dashoffset', 0);

            // Forecast line
            const forecastPath = svg.append('path')
                .datum(forecast)
                .attr('fill', 'none')
                .attr('stroke', '#A5B4FF')
                .attr('stroke-width', 3)
                .attr('stroke-dasharray', '8,4')
                .attr('d', line);

            const forecastLength = forecastPath.node().getTotalLength();

            forecastPath
                .attr('stroke-dasharray', forecastLength)
                .attr('stroke-dashoffset', forecastLength)
                .transition()
                .delay(2500)
                .duration(1500)
                .ease(d3.easeQuadInOut)
                .attr('stroke-dashoffset', 0)
                .on('end', () => {
                    forecastPath.attr('stroke-dasharray', '8,4');
                });

            // Grid lines
            svg.append('g')
                .attr('class', 'grid')
                .attr('transform', `translate(0,${height - margin.bottom})`)
                .call(d3.axisBottom(x)
                    .ticks(12)
                    .tickSize(-height + margin.top + margin.bottom)
                    .tickFormat(''))
                .style('stroke-dasharray', '2,2')
                .style('stroke-opacity', 0.2);

            // Axes
            svg.append('g')
                .attr('transform', `translate(0,${height - margin.bottom})`)
                .call(d3.axisBottom(x).ticks(12))
                .attr('color', '#5A6472');

            svg.append('g')
                .attr('transform', `translate(${margin.left},0)`)
                .call(d3.axisLeft(y))
                .attr('color', '#5A6472');
        }

        // Enhanced scatter plot
        let scatterCreated = false;
        function createScatterPlot() {
            if (scatterCreated) return;
            scatterCreated = true;

            const container = d3.select('#scatter-container');
            container.selectAll('*').remove();
            
            const rect = container.node().getBoundingClientRect();
            const width = rect.width;
            const height = 400;
            const margin = { top: 20, right: 20, bottom: 50, left: 50 };

            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height)
                .attr('viewBox', `0 0 ${width} ${height}`)
                .attr('preserveAspectRatio', 'xMidYMid meet');

            // Generate correlated data with some realistic scatter
            const data = d3.range(60).map(i => {
                const actual = 30 + Math.random() * 40;
                const error = (Math.random() - 0.5) * 8 * (1 - i / 60); // Error decreases over time
                const predicted = actual + error;
                return { actual, predicted };
            });

            const x = d3.scaleLinear()
                .domain([20, 80])
                .range([margin.left, width - margin.right]);

            const y = d3.scaleLinear()
                .domain([20, 80])
                .range([height - margin.bottom, margin.top]);

            // Grid
            svg.append('g')
                .attr('class', 'grid')
                .attr('transform', `translate(0,${height - margin.bottom})`)
                .call(d3.axisBottom(x)
                    .tickSize(-height + margin.top + margin.bottom)
                    .tickFormat(''))
                .style('stroke-dasharray', '2,2')
                .style('stroke-opacity', 0.1);

            svg.append('g')
                .attr('class', 'grid')
                .attr('transform', `translate(${margin.left},0)`)
                .call(d3.axisLeft(y)
                    .tickSize(-width + margin.left + margin.right)
                    .tickFormat(''))
                .style('stroke-dasharray', '2,2')
                .style('stroke-opacity', 0.1);

            // Perfect correlation line
            svg.append('line')
                .attr('x1', x(20))
                .attr('y1', y(20))
                .attr('x2', x(20))
                .attr('y2', y(20))
                .attr('stroke', '#CFFAFB')
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '6,3')
                .attr('opacity', 0.8)
                .transition()
                .duration(2000)
                .attr('x2', x(80))
                .attr('y2', y(80));

            // Scatter points with size variation
            svg.selectAll('circle')
                .data(data)
                .enter()
                .append('circle')
                .attr('cx', d => x(d.actual))
                .attr('cy', d => y(d.predicted))
                .attr('r', 0)
                .attr('fill', '#A5B4FF')
                .attr('opacity', 0)
                .transition()
                .delay((d, i) => i * 20 + 500)
                .duration(800)
                .attr('r', d => 3 + Math.random() * 3)
                .attr('opacity', 0.6 + Math.random() * 0.3);

            // Axes
            svg.append('g')
                .attr('transform', `translate(0,${height - margin.bottom})`)
                .call(d3.axisBottom(x))
                .attr('color', '#5A6472');

            svg.append('text')
                .attr('x', width / 2)
                .attr('y', height - 5)
                .attr('text-anchor', 'middle')
                .attr('font-size', '12px')
                .attr('fill', '#5A6472')
                .text('Actual Demand (tons)');

            svg.append('g')
                .attr('transform', `translate(${margin.left},0)`)
                .call(d3.axisLeft(y))
                .attr('color', '#5A6472');

            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('x', -height / 2)
                .attr('y', 15)
                .attr('text-anchor', 'middle')
                .attr('font-size', '12px')
                .attr('fill', '#5A6472')
                .text('Predicted Demand (tons)');
        }

        // Dashboard panels animation
        function showDashboards() {
            const panels = document.querySelectorAll('.dashboard-panel');
            panels.forEach((panel, i) => {
                setTimeout(() => {
                    panel.classList.add('visible');
                }, i * 200);
            });
        }

        // Enhanced network graph
        let networkCreated = false;
        function createNetworkGraph() {
            if (networkCreated) return;
            networkCreated = true;

            const container = d3.select('#network-container');
            container.selectAll('*').remove();
            
            const rect = container.node().getBoundingClientRect();
            const width = rect.width;
            const height = 400;

            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height)
                .attr('viewBox', `0 0 ${width} ${height}`)
                .attr('preserveAspectRatio', 'xMidYMid meet');

            const nodes = [
                { id: 'HYPERION', x: width / 2, y: height / 2, r: 35, color: '#A5B4FF' },
                { id: 'Data', x: width / 2 - 150, y: height / 2 - 120, r: 25, color: '#CFFAFB' },
                { id: 'Model', x: width / 2 + 150, y: height / 2 - 120, r: 25, color: '#C6E1FF' },
                { id: 'Forecast', x: width / 2 - 150, y: height / 2 + 120, r: 25, color: '#CFFAFB' },
                { id: 'Strategy', x: width / 2 + 150, y: height / 2 + 120, r: 25, color: '#C6E1FF' },
                { id: 'Insight', x: width / 2, y: height / 2 - 180, r: 20, color: '#E8ECEF' },
                { id: 'Action', x: width / 2, y: height / 2 + 180, r: 20, color: '#E8ECEF' }
            ];

            const links = [
                { source: nodes[0], target: nodes[1] },
                { source: nodes[0], target: nodes[2] },
                { source: nodes[0], target: nodes[3] },
                { source: nodes[0], target: nodes[4] },
                { source: nodes[1], target: nodes[5] },
                { source: nodes[2], target: nodes[5] },
                { source: nodes[3], target: nodes[6] },
                { source: nodes[4], target: nodes[6] }
            ];

            // Animated gradient for links
            const defs = svg.append('defs');
            const linkGradient = defs.append('linearGradient')
                .attr('id', 'link-gradient');
            
            linkGradient.append('stop')
                .attr('offset', '0%')
                .attr('stop-color', '#A5B4FF')
                .attr('stop-opacity', 0.2);
            
            linkGradient.append('stop')
                .attr('offset', '50%')
                .attr('stop-color', '#A5B4FF')
                .attr('stop-opacity', 0.6);
            
            linkGradient.append('stop')
                .attr('offset', '100%')
                .attr('stop-color', '#A5B4FF')
                .attr('stop-opacity', 0.2);

            // Links with animation
            const linkElements = svg.selectAll('line')
                .data(links)
                .enter()
                .append('line')
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.source.x)
                .attr('y2', d => d.source.y)
                .attr('stroke', '#C6E1FF')
                .attr('stroke-width', 2)
                .attr('opacity', 0.4)
                .transition()
                .delay((d, i) => i * 100)
                .duration(1000)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);

            // Node groups
            const nodeGroups = svg.selectAll('g.node')
                .data(nodes)
                .enter()
                .append('g')
                .attr('class', 'node')
                .attr('transform', d => `translate(${d.x}, ${d.y})`);

            // Node circles with glow effect
            nodeGroups.append('circle')
                .attr('r', 0)
                .attr('fill', d => d.color)
                .attr('opacity', 0.8)
                .attr('filter', 'drop-shadow(0 0 10px rgba(165, 180, 255, 0.5))')
                .transition()
                .delay((d, i) => i * 150 + 500)
                .duration(800)
                .ease(d3.easeBackOut.overshoot(1.2))
                .attr('r', d => d.r);

            // Node labels
            nodeGroups.append('text')
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr('font-size', d => d.r > 25 ? '14px' : '11px')
                .attr('font-weight', '600')
                .attr('fill', '#1A1F2E')
                .attr('opacity', 0)
                .text(d => d.id)
                .transition()
                .delay((d, i) => i * 150 + 1000)
                .duration(500)
                .attr('opacity', 1);

            // Pulsing animation for central node
            const centralNode = nodeGroups.filter(d => d.id === 'HYPERION').select('circle');
            
            function pulse() {
                centralNode
                    .transition()
                    .duration(2000)
                    .attr('r', 40)
                    .attr('opacity', 0.6)
                    .transition()
                    .duration(2000)
                    .attr('r', 35)
                    .attr('opacity', 0.8)
                    .on('end', pulse);
            }
            
            setTimeout(pulse, 2000);
        }

        // Window resize handler
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                scroller.resize();
                
                // Clear and recreate visualizations on resize
                streamCreated = false;
                treeVizCreated = false;
                barChartCreated = false;
                forecastCreated = false;
                scatterCreated = false;
                networkCreated = false;
            }, 250);
        });

        // Prevent horizontal scroll on mobile
        document.addEventListener('touchmove', function(e) {
            if (Math.abs(e.touches[0].clientX - e.touches[0].clientX) > 10) {
                e.preventDefault();
            }
        }, { passive: false });
    </script>
</body>
</html>